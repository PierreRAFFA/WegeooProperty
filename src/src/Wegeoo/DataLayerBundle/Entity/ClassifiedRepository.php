<?php

namespace Wegeoo\DataLayerBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Query;
use Symfony\Component\HttpFoundation\Session\Session;
use Wegeoo\DataLayerBundle\Controller\ClassifiedController;
use Wegeoo\DataLayerBundle\Entity\Classified;
use Doctrine\ORM\Query\Lexer;
use Wegeoo\WebsiteBundle\Controller\WegeooWebsiteClassifiedController;
use Wegeoo\WebsiteBundle\Controller\WegeooWebsiteHomeController;
use Wegeoo\WebsiteBundle\Controller\WegeooWebsitePostController;

/**
 * ClassifiedRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ClassifiedRepository extends EntityRepository
{
    const MAX_NUMBER_OF_LATEST_CLASSIFIEDS = 15;

    const DATATYPE_STRING       = "string";
    const DATATYPE_ENUM         = "enum";
    const DATATYPE_LATLNGZOOM   = "latLngZoom";
    const DATATYPE_INTERVAL     = "interval";

	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Returns Classified Ad from one reference.
	 * 
	 * @param $pReference string
	 * @return array Doctrine result
	 */
	 
	public function getClassifiedFromReferenceAction($pReference)
	{
		$lQueryBuilder = $this->_em->createQueryBuilder();
		//$lQueryBuilder->select('cl.id,cl.reference','cl.type', 'cl.title','cl.description', 'cl.details','cl.contact','cl.latitude','cl.longitude','cl.modificationDate','cl.contactType','cl.isExternal','cl.externalLink','cl.externalMedias','City.postCode AS cityPostCode' , 'City.name AS cityName' )
		$lQueryBuilder->select('cl')
				      ->from($this->_entityName , 'cl')
                      ->leftJoin('cl.city', 'City')
					  /*->innerjoin(
				            'Wegeoo\DataLayerBundle\Entity\City',
				            'ci',
				            \Doctrine\ORM\Query\Expr\Join::WITH,
				            'cl.cityId = ci.cityId')*/
					  ->where("cl.reference = :reference")
                      ->setParameter("reference" , $pReference);


		$lQuery = $lQueryBuilder->getQuery()->getSQL();
		$lResults = $lQueryBuilder->getQuery()->getResult();

        //echo var_export($lResults,true);
        WegeooWebsiteClassifiedController::$LOGGER->info("count(lResult):".count($lResults));
        if (count($lResults) == 1)
        {
            //Only one data is possible because reference is unique.
            $lClassified = $lResults[0];
            //WegeooWebsiteClassifiedController::$LOGGER->info($lClassified);
            //check if active
            if ( TRUE || $lClassified->getActive())
            {
                // A refaire car c'est pas normal de devoir instancier un classified. Le repository devrait renvoyer un Classified
                //$lClassified = new Classified();
                //$lClassified->setReference($pReference);
                $lClassified->findMedias();
                //insert medias and qrcode to the result
                //@TODO $lFinder = new Finder($lClassified->getMediasDirectory());
                //$lResult["medias"] = $lClassified->getMedias($pReference);
                //echo var_export($lResult["medias"],true);
                $lResult["qrcode"] = $lClassified->getQRCode();
                $lResult["contact"]["logo"] = $lClassified->getLogo();
            }

        }else{
            $lClassified = FALSE;
        }

        //WegeooWebsiteClassifiedController::$LOGGER->info(var_export($lClassified,true));
		return $lClassified;
	}

	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Sorts results and returns Preview Classified Ad ( title, description, price, city name, city postCode) from references.
	 * 
	 * @param $pReferences array of reference
	 * @param $pSort formed as 'fieldSORT'
	 * @return array Doctrine Result sorted
	 */
	public function getPreviewClassifiedFromReferencesAction($pReferences,$pSort)
	{
		$lQueryBuilder = $this->_em->createQueryBuilder(); 
		
		$lQueryBuilder->select('cl')
				      ->from($this->_entityName , 'cl')
                      ->leftJoin('cl.city', 'City');
					  /*->leftJoin(
				            'Wegeoo\DataLayerBundle\Entity\City',
				            'ci',
				            \Doctrine\ORM\Query\Expr\Join::WITH,
				            'cl.codgeo = ci.codgeo');*/
					  
		foreach($pReferences as $lIndex=>$lReference)
		{
			$lQueryBuilder->orWhere("cl.reference = :reference$lIndex")
            ->setParameter("reference$lIndex" , $lReference);
		}

        $lQuery = $lQueryBuilder->getQuery()->getSQL();
        //ClassifiedController::$LOGGER->info(var_export($lQuery,true));

		//exec query
		$lResults = $lQueryBuilder->getQuery()->getResult();

        //ClassifiedController::$LOGGER->info(var_export($lResults,true));
        /** HACK Doctrine does not manage request based on json keys */
        foreach($lResults as $lResult)
        {
            $lResult->findMedias();

            //$lResult["medias"] = $lClassified->getMedias($pReference);

			//echo var_export($lResult,true);
//			if (isset($lResult["details"]))
//			{
//				$lDetails = $lResult["details"];
//				if ( isset($lDetails["price"]))
//				{
//					$lPrice = $lDetails["price"];
//					$lResult["price"] = $lPrice;
//				}
//				unset($lResult["details"]);
//			}
		}
		/** HACK Doctrine does not manage request based on json keys */
	  	
	  	
	  	/** HACK Doctrine does not manage request based on json keys for sort*/
	  	switch($pSort)
		{
			case "priceDESC":
				uasort($lResults , function($pA,$pB){
                    if ( isset($pA->getDetails()["price"]) == FALSE) return -1;
                    if ( isset($pB->getDetails()["price"]) == FALSE) return 1;
					return $pA->getDetails()["price"] < $pB->getDetails()["price"];
			  	});
				break;
			case "priceASC":
				uasort($lResults , function($pA,$pB){
                    if ( isset($pA->getDetails()["price"]) == FALSE) return -1;
                    if ( isset($pB->getDetails()["price"]) == FALSE) return 1;
					return $pA->getDetails()["price"] > $pB->getDetails()["price"];
			  	});
				break;
			case "dateDESC":
				uasort($lResults , function($pA,$pB){
					return $pA->getModificationDate() < $pB->getModificationDate();
			  	});
				break;
				
			//@TODO
		}
	  	/** HACK Doctrine does not manage request based on json keys for sort*/
	  	
		return $lResults;
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Returns Classified Ad from filter.
     * This method can be called each time the map position has changed,
     * so there is a filter by reference to avoid sending the references already sent
	 * 
	 * @param $pFilterParams array of filter parameter
	 * @return array Doctrine result
	 */
	public function getClassifiedsGeolocation($pFilterParams)
    {
        //start session
        $lSession = new Session();
        $lSession->start();

        //active to debug
        //$lSession->clear();

        //compute search id ( remove map informations )
        $lSessionFilterParams = clone $pFilterParams;
        unset($lSessionFilterParams->map);
        $lSearchId = sprintf("%s-%s" , $lSession->getId(),  md5(json_encode($lSessionFilterParams)) );

        ClassifiedController::$LOGGER->info(var_export($lSessionFilterParams,true));
        ClassifiedController::$LOGGER->info("=======================================");
        ClassifiedController::$LOGGER->info("lSearchId:".$lSearchId);
        ClassifiedController::$LOGGER->info("=======================================");

        ClassifiedController::$LOGGER->info("pFilterParams:".var_export($pFilterParams,true));

        ClassifiedController::$LOGGER->info("lSession->has(lSearchId):".var_export($lSession->has("search_id"),true));
        if ( $lSession->get("search_id") != $lSearchId )
        {
            ClassifiedController::$LOGGER->info("lSession->has(lSearchId):".var_export($lSession->has("search_id"),true));
            $lSession->set("search_id" , $lSearchId);
            $lSession->remove("references");
        }

        //{"ci":"rent","cn":"montpellier","pc":"34000","pt":"0,1","nr":"4,5+"}
		$lFullResults = array();

        //create city query
        $lSlugName      = strtolower(sprintf("%s-%s" , $pFilterParams->cityPostCode , str_replace(" " , "-" , $pFilterParams->cityName)));
        $lCityName 		= strtoupper($pFilterParams->cityName);
        $lCityPostCode 	= $pFilterParams->cityPostCode;

        $lCityQueryBuilder = $this->_em->createQueryBuilder();
        $lCityQueryBuilder = $lCityQueryBuilder->select('ci.id', 'ci.postCode' , 'ci.name','ci.uppercaseName','ci.latitude', 'ci.longitude', 'ci.pop', 'ci.code' )
            ->from('Wegeoo\DataLayerBundle\Entity\City' , 'ci')
            ->where("ci.slugName = '$lSlugName'");

        $lCityResults = $lCityQueryBuilder->getQuery()->getResult();

        ClassifiedController::$LOGGER->info("lCityResult:".var_export($lCityResults,true));

        if ( count($lCityResults))
        {
            $lCityResult = $lCityResults[0];
            $lCityId = $lCityResult["id"];

            //if map is setted, then select the map query otherwise select the city query.
            if (isset($pFilterParams->map))
            {
                $lQuery = "SELECT cl.reference , cl.latitude , cl.longitude, cl.modification_date, cl.details
FROM classified cl
WHERE";
            }else{
                //to force the clause of geolocation
                $pFilterParams->map = "";

                $lQuery = "SELECT cl.reference , cl.latitude , cl.longitude, cl.modification_date, cl.details
FROM classified cl
LEFT JOIN city ci
ON cl.city_id = ci.id
WHERE cl.city_id = '$lCityId' AND";

                $lQuery = "SELECT cl.reference , cl.latitude , cl.longitude, cl.modification_date, cl.details
FROM classified cl
WHERE ";
            }

            $lClauses = "";
            foreach($pFilterParams as $pFilterParamName=>$pFilterParamValue)
            {
                //these parameters is used above
                switch($pFilterParamName)
                {
                    case "cityPostCode":
                    case "cityName":
                    case "theme":
                        //nothing
                        break;

                    case "category":
                        $lClauses .= "AND cl.category = '$pFilterParamValue' ";
                        break;

                    case "map":
                        preg_match('/@\(\(([-.0-9]*),([-.0-9]*)\),\(([-.0-9]*),([-.0-9]*)\)\)/' , $pFilterParamValue , $lBounds);
                        ClassifiedController::$LOGGER->info("lBounds:".var_export($lBounds,true));

                        if ( count($lBounds) == 5)
                        {
                            //check if search is an update or a new.
                            if ( $lSession->has("references"))
                            {
                                $lClauses .= sprintf("AND cl.latitude >= %s AND cl.latitude <= %s AND cl.longitude >= %s AND cl.longitude <= %s " ,
                                    $lBounds[1], $lBounds[3], $lBounds[2], $lBounds[4] );
                            }else{
                                //report bounds to the city latLng
                                $ldLat = abs($lBounds[1] - $lBounds[3]);
                                $ldLng = abs($lBounds[2] - $lBounds[4]);

                                ClassifiedController::$LOGGER->info("ldLat:".$ldLat);
                                ClassifiedController::$LOGGER->info("ldLng:".$ldLng);
                                ClassifiedController::$LOGGER->info("lCityResult[latitude]:".$lCityResult["latitude"]);
                                ClassifiedController::$LOGGER->info("lCityResult[longitude]:".$lCityResult["longitude"]);
                                $lClauses .= sprintf("AND cl.latitude >= %s AND cl.latitude <= %s AND cl.longitude >= %s AND cl.longitude <= %s " ,
                                    $lCityResult["latitude"] - $ldLat/2 , $lCityResult["latitude"] + $ldLat/2 , $lCityResult["longitude"] - $ldLng/2 , $lCityResult["longitude"] + $ldLng/2);
                            }

                        }else{

                            $ldLat = 0.06;
                            $ldLng = $ldLat * 7;
                            $lClauses .= sprintf("AND cl.latitude >= %s AND cl.latitude <= %s AND cl.longitude >= %s AND cl.longitude <= %s " ,
                                $lCityResult["latitude"] - $ldLat/2 , $lCityResult["latitude"] + $ldLat/2 , $lCityResult["longitude"] - $ldLng/2 , $lCityResult["longitude"] + $ldLng/2);

                            //$lClauses .= sprintf("AND compute_distance_between_latlng(cl.latitude,cl.longitude,%s,%s) < %s " , $lCityResult["latitude"] , $lCityResult["longitude"] , 10000);
                        }
                        break;

                    default:
                        if ( $pFilterParamName == "numRooms")
                        {
                            //To display check if filters is usefull because of external classified without any infos about it
                            if ($pFilterParamValue = "1,2,3,4,5+" )
                                continue;
                        }

                        $lFieldType = $this->getFieldTypeFromValue($pFilterParamValue);
                        ClassifiedController::$LOGGER->info("lFieldType:".$lFieldType);

                        switch ($lFieldType)
                        {
                            case self::DATATYPE_STRING:
                            case "integer":
                            $lClauses .= " AND cl.details->>'$pFilterParamName' = '$pFilterParamValue'";
                                break;

                            case self::DATATYPE_ENUM:
                                $lSubQuery = "";
                                //$pFilterParamValue = explode(",", $pFilterParamValue );
                                foreach ($pFilterParamValue as $lExplodedValue)
                                {

                                    if ( substr($lExplodedValue, -1) == "+")
                                    {
                                        $lRealExplodedValue = substr($lExplodedValue , 0 , -1);
                                        $lSubQuery .= ($lSubQuery == "" ? "" : " OR ") . "cl.details->>'$pFilterParamName' >= '$lRealExplodedValue'";
                                    }else{
                                        $lSubQuery .= ($lSubQuery == "" ? "" : " OR ") . "cl.details->>'$pFilterParamName' = '$lExplodedValue'";
                                    }
                                }

                                $lClauses .= sprintf(" AND (%s)" , $lSubQuery);
                                break;

                            case self::DATATYPE_INTERVAL:
                                $lExplodedValues = explode(";", $pFilterParamValue);

                                $lSubQuery = "";
                                foreach ($lExplodedValues as $lIndex=>$lExplodedValue)
                                {
                                    if ( $lIndex == 0)
                                    {
                                        if ( $lExplodedValue != "min" && $lExplodedValue != "")
                                            $lSubQuery .= ($lSubQuery == "" ? "" : " AND ") . sprintf("cast(cl.details->>'%s' as int) >= '%s'" , $pFilterParamName,  $lExplodedValue );
                                    }else  if ( $lIndex == 1){
                                        if ( $lExplodedValue != "max" && $lExplodedValue != "")
                                            $lSubQuery .= ($lSubQuery == "" ? "" : " AND ") . sprintf("cast(cl.details->>'%s' as int) <= '%s'" , $pFilterParamName,  $lExplodedValue );
                                    }

                                }

                                $lClauses .= sprintf(" AND (%s)" , $lSubQuery);
                                break;
                        }

                }
            }

            //ignores references already sent
            if ($lSession->has("references"))
            {
                $lAny = "";
                $lAlreadySentReferences = $lSession->get("references");

                if ( count($lAlreadySentReferences))
                {
                    foreach($lAlreadySentReferences as $lAlreadySentReference)
                    {
                        $lAny .= ($lAny?",":"") . "'" . $lAlreadySentReference . "'";
                    }
                    $lClauses .= sprintf(" AND cl.reference NOT IN (%s)" , $lAny );
                }
            }

            //to remove first AND
            $lQuery .= substr($lClauses , 3);

            ClassifiedController::$LOGGER->info("lQuery:".$lQuery);

            //Here, we don't use DQL because it does not support 'select' query with json fields
            $lConnection = $this->_em->getConnection();
            $lStatement = $lConnection->prepare($lQuery);
            $lStatement->execute();
            $lResults = $lStatement->fetchAll();
            //trigger_error("lResults:".var_export($lResults,true));

            /** HACK Doctrine does not manage 'select' requests based on json fields */
            $lReferencesToRegister = array();
            foreach($lResults as &$lResult)
            {
                //register reference to the references of session
                $lReferencesToRegister[] = $lResult["reference"];

                if (isset($lResult["details"]))
                {
                    $lDetails = $lResult["details"];
                    $lDetailsJSON = json_decode($lDetails);
                    if ( isset($lDetailsJSON->price))
                    {
                        $lPrice = $lDetailsJSON->price;
                        $lResult["price"] = $lPrice;
                    }
                    unset($lResult["details"]);
                }
            }
            /** HACK Doctrine does not manage 'select' requests based on json fields */

            //set full results
            $lFullResults["classifieds"] = $lResults;

            ClassifiedController::$LOGGER->info("lSession->has(references):".var_export($lSession->has("references"),true));

            //remove city if it's not the first search with this parameters
            if ( $lSession->has("references") == FALSE)
                $lFullResults["city"] = $lCityResult;

            //register all references
            if ( $lSession->has("references"))
            {
                $lReferences = $lSession->get("references");
                $lMergedReferences = array_merge($lReferences , $lReferencesToRegister);
                $lSession->set("references", $lMergedReferences);

            }else{
                $lSession->set("references", $lReferencesToRegister);
            }
        }
        //ClassifiedController::$LOGGER->info(var_export($lFullResults,true));
        return $lFullResults;
	}


    protected function getFieldTypeFromValue($value)
    {
        ClassifiedController::$LOGGER->info(__METHOD__);
        ClassifiedController::$LOGGER->info(var_export($value,true));

        //Array ?
        if ( is_array($value))
            return self::DATATYPE_ENUM;

        $lRegExp    = '/[a-z0-9]*,[a-z0-9]*/';
        preg_match($lRegExp , $value , $lMatches);
        if ( count($lMatches))
            return self::DATATYPE_ENUM;

        // Interval ?
        $lRegExp    = '/[a-z0-9]*;[a-z0-9]*/';
        preg_match($lRegExp , $value , $lMatches);
        if ( count($lMatches))
            return self::DATATYPE_INTERVAL;


        // LatLngZoom ?
        $lRegExp  = '/@\(\([-.0-9]*,[-.0-9]*\),\([-.0-9]*,[-.0-9]*\)\)/';
        preg_match($lRegExp , $value , $lMatches);
        if ( count($lMatches))
            return self::DATATYPE_LATLNGZOOM;

        return self::DATATYPE_STRING;
    }


    ////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////// GET LATEST CLASSIFIEDS
    /**
     * @param $filterParams
     * @return array Array of Classified
     */
    public function getLatestClassifiedsAround($filterParams)
    {
        //test if ClassifiedsIn returns enough results, otherwise broaden the search
        $lClassifieds = $this->getLatestClassifiedsIn($filterParams);
        if ( count($lClassifieds) < self::MAX_NUMBER_OF_LATEST_CLASSIFIEDS)
        {
            $lClassifieds = array();

            //create city query
            $lCityName      = strtoupper($filterParams->cityName);
            $lCityPostCode  = $filterParams->cityPostCode;
            $lCategory      = $filterParams->category;

            //get city
            $lCityQueryBuilder = $this->_em->createQueryBuilder();
            $lCityQueryBuilder = $lCityQueryBuilder->select('ci')
                ->from('Wegeoo\DataLayerBundle\Entity\City', 'ci')
                ->where("ci.uppercaseName = '$lCityName'")
                ->andWhere("ci.postCode = '$lCityPostCode'");

            $lCityResults = $lCityQueryBuilder->getQuery()->getResult();

            if (count($lCityResults) == 1)
            {
                $lCity = $lCityResults[0];

                $lLat = $lCity->getLatitude();
                $lLng = $lCity->getLongitude();



                $lRadius = 0.02;
                $lQuery = $this->_em->createQueryBuilder()
                    ->select('partial cl.{id,reference,category,title,city,details,externalMedias}')
                    ->from('WegeooDataLayerBundle:Classified' , 'cl')
                    ->where('cl.latitude >= :latitudeMin AND cl.latitude <= :latitudeMax AND cl.longitude >= :longitudeMin AND cl.longitude <= :longitudeMax')
                    ->andWhere("cl.category = :category")
                    ->setParameter("category"     , $lCategory )
                    ->setParameter("latitudeMin"  , $lLat - $lRadius )
                    ->setParameter("latitudeMax"  , $lLat + $lRadius )
                    ->setParameter("longitudeMin" , $lLng - $lRadius )
                    ->setParameter("longitudeMax" , $lLng + $lRadius )
                    ->setMaxResults(self::MAX_NUMBER_OF_LATEST_CLASSIFIEDS)
                    ->getQuery();
                $lClassifieds = $lQuery->getResult();

                foreach($lClassifieds as $lClassified)
                {
                    $lClassified->findMedias();
                }
            }
            ClassifiedController::$LOGGER->info(var_export($lClassifieds,true));
        }

        return $lClassifieds;
    }
    /**
     * @param $filterParams
     * @return array Array of Classified
     */
    public function getLatestClassifiedsIn($filterParams)
    {
        $lCityName 		= strtoupper($filterParams->cityName);
        $lCityPostCode 	= $filterParams->cityPostCode;
        $lCategory      = $filterParams->category;

        $lQuery = $this->_em->createQueryBuilder()
            ->select('cl' , 'ci')
            ->from('WegeooDataLayerBundle:Classified' , 'cl')
            ->leftjoin('cl.city', 'ci')
            ->where('cl.category = :category AND ((ci.uppercaseName = :uppercaseName AND ci.postCode = :postCode) OR ci.parentCode = :parentCode)')
            ->setParameter("category" , $lCategory)
            ->setParameter("uppercaseName" , $lCityName)
            ->setParameter("postCode" , $lCityPostCode)
            ->setParameter("parentCode" , strtolower($lCityName))
            ->orderBy("cl.modificationDate" , "DESC")
            ->setMaxResults(self::MAX_NUMBER_OF_LATEST_CLASSIFIEDS)
            ->getQuery();

        //ClassifiedController::$LOGGER->info(sprintf(str_replace('?', '%s', $lClassifieds->getSql()), $lClassifieds->getParams()));
        $lClassifieds = $lQuery->getResult();

        foreach($lClassifieds as $lClassified)
        {
            $lClassified->findMedias();
        }

        return $lClassifieds;
    }

    /**
     * Deletes all expired classifieds ( > 30 days )
     * This method must be called by cron
     *
     * @return number of classifieds deleted
     */
    public function deleteExpiredClassifieds()
    {
        //get num classifieds to delete
        $lQuery = $this->_em->createQueryBuilder()
            ->select('cl')
            ->from('WegeooDataLayerBundle:Classified' , 'cl')
            ->where('cl.modificationDate < :date')
            ->setParameter('date' , date('Y-m-d H:i:s', time() - 86400 * Classified::EXPIRATION_DELAY))
            ->getQuery();
        $lNum = count($lQuery->getResult());

        //delete this classifieds
        $lQuery = $this->_em->createQueryBuilder()
            ->delete()
            ->from('WegeooDataLayerBundle:Classified' , 'cl')
            ->where('cl.modificationDate < :date')
            ->setParameter('date' , date('Y-m-d H:i:s', time() - 86400 * Classified::EXPIRATION_DELAY))
            ->getQuery();
        $lQuery->getResult();


        return $lNum;
    }
}
